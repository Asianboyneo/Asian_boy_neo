<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <!-- iOS è¦–å£å„ªåŒ–ï¼šviewport-fit=cover æ˜¯é—œéµï¼Œè®“å…§å®¹å»¶ä¼¸åˆ°ç€æµ·å€ -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Cosmic Particles (Unified Space Glass UI)</title>
    
    <!-- å¼•å…¥ Font Awesome åœ–æ¨™åº« -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">

    <!-- æ¨£å¼è¨­è¨ˆ -->
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #020205;
            /* ç¾ä»£ç„¡è¥¯ç·šå­—é«”ï¼Œä¹¾æ·¨å„ªé›… */
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;

            /* --- é—œéµä¿®æ­£ï¼šé–å®š Body é˜²æ­¢æ‰‹æ©Ÿç€è¦½å™¨æ»¾å‹•å›å½ˆèˆ‡å·¥å…·åˆ—é®æ“‹ --- */
            position: fixed;
            width: 100%;
            height: 100%;
            overscroll-behavior: none;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            /* ä½¿ç”¨ dvh (Dynamic Viewport Height) æ‡‰å°æ‰‹æ©Ÿç€è¦½å™¨ç¶²å€åˆ—ä¼¸ç¸® */
            height: 100dvh; 
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #video-input {
            position: absolute;
            top: 0;
            left: 0;
            width: 1px;
            height: 1px;
            opacity: 0;
            pointer-events: none;
            z-index: -1;
        }

        /* --- å¤ªç©ºæ¯›ç»ç’ƒ UI æ ¸å¿ƒè¨­è¨ˆ (å·¦ä¸‹è§’é¢æ¿) --- */
        #ui-layer {
            /* --- é€šç”¨/é›»è…¦ç‰ˆè¨­å®šï¼šé å·¦ä¸‹æ–¹ --- */
            position: fixed; 
            bottom: 30px;
            left: 20px; /* é›»è…¦ç‰ˆï¼šé å·¦ */
            transform: none; /* é›»è…¦ç‰ˆï¼šä¸é€²è¡Œä½ç§»ä¿®æ­£ */
            
            max-width: 420px; /* ç¨å¾®åŠ å¯¬ä»¥å®¹ç´æ–°æŒ‰éˆ• */
            width: calc(100% - 40px);
            
            color: rgba(255, 255, 255, 0.95);
            z-index: 10;
            pointer-events: none;
            
            /* --- å›å¾©åŸæœ¬çš„æ¯›ç»ç’ƒæ•ˆæœ --- */
            /* 1. å¤ªç©ºæ„Ÿæ·±è‰²åŠé€æ˜èƒŒæ™¯ */
            background: rgba(20, 25, 40, 0.4); 
            
            /* 2. æ¨™æº–æ¨¡ç³Šåº¦ */
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            
            padding: 24px;
            
            /* 3. åŸæœ¬çš„åœ“è§’ */
            border-radius: 24px;
            
            /* 4. åŸæœ¬çš„ç´°ç·»é‚Šæ¡† */
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            border-bottom: 1px solid rgba(0, 0, 0, 0.2);
            
            /* 5. åŸæœ¬çš„é™°å½± */
            box-shadow: 
                0 10px 40px rgba(0, 0, 0, 0.4),
                inset 0 0 0 1px rgba(255, 255, 255, 0.05);
            
            transition: opacity 0.3s ease;
            
            /* è®“æ•´å€‹å®¹å™¨å…§çš„æ–‡å­—é è¨­ç½®ä¸­ */
            text-align: center;
        }
        
        /* è®“é¢æ¿å…§çš„äº’å‹•å…ƒç´ å¯ä»¥è¢«é»æ“Š */
        #ui-layer > * {
            pointer-events: auto;
        }

        h1 {
            font-weight: 300;
            margin: 0 0 12px 0;
            font-size: 1.5rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            /* å›å¾©åŸæœ¬çš„æ¼¸å±¤ */
            background: linear-gradient(120deg, #ffffff 0%, #a5b4fc 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            position: relative;
            padding-bottom: 12px;
            text-align: center;
            text-shadow: none;
        }
        
        h1::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 2px;
            background: rgba(165, 180, 252, 0.5);
            border-radius: 2px;
            box-shadow: none;
        }

        /* --- é¢æ¿å…§çš„ç¤¾ç¾¤æŒ‰éˆ•åˆ— --- */
        .social-row {
            display: flex;
            gap: 10px;
            margin-bottom: 15px; 
            pointer-events: auto; 
            justify-content: center;
        }

        .social-btn {
            color: rgba(255, 255, 255, 0.7);
            font-size: 1.1rem;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            /* å›å¾©åŸæœ¬æŒ‰éˆ•æ¨£å¼ */
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-decoration: none;
            box-shadow: none;
        }

        .social-btn:hover {
            color: #fff;
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(165, 180, 252, 0.3);
            border-color: rgba(165, 180, 252, 0.4);
        }

        .social-btn:hover .fa-instagram { color: #e1306c; text-shadow: none; }
        .social-btn:hover .fa-youtube { color: #ff0000; text-shadow: none; }
        .social-btn:hover .fa-threads { color: #fff; text-shadow: none; } 
        .social-btn:hover .fa-mug-hot { color: #13C3FF; text-shadow: none; } 

        /* --- åº•éƒ¨è³‡è¨Šèˆ‡æŒ‰éˆ•åˆ— --- */
        .ui-footer-row {
            margin-top: 12px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: center;
            gap: 8px; /* æŒ‰éˆ•é–“è· */
            align-items: center;
            flex-wrap: wrap; /* å…è¨±æ›è¡Œä»¥é©æ‡‰å°è¢å¹• */
        }

        /* å›å¾©åŸæœ¬çš„æŒ‰éˆ•æ¨£å¼ */
        .mode-btn, .reset-btn {
            background: transparent;
            border: 1px solid rgba(165, 180, 252, 0.3);
            color: rgba(165, 180, 252, 0.8);
            border-radius: 6px;
            padding: 4px 10px; /* ç¨å¾®ç¸®å°å…§è·ä»¥å®¹ç´æ›´å¤šæŒ‰éˆ• */
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            gap: 6px;
            outline: none;
            justify-content: center;
            white-space: nowrap; /* ç¢ºä¿æ–‡å­—ä¸æ›è¡Œ */
            user-select: none; /* é˜²æ­¢é•·æŒ‰é¸å–æ–‡å­— */
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            
            backdrop-filter: none;
            box-shadow: none;
        }

        .mode-btn:hover, .reset-btn:hover {
            background: rgba(165, 180, 252, 0.15);
            color: #fff;
            border-color: #a5b4fc;
            box-shadow: 0 0 12px rgba(165, 180, 252, 0.4);
            transform: translateY(-1px);
        }
        
        .mode-btn:active, .reset-btn:active {
            transform: translateY(1px);
            background: rgba(165, 180, 252, 0.25);
        }
        
        .mode-btn.active-photo, .reset-btn.active-music {
            background: rgba(165, 180, 252, 0.25);
            color: #fff;
            border-color: #fff;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.4);
        }

        /* --- lil-gui å¤ªç©ºæ¯›ç»ç’ƒé¢¨æ ¼ --- */
        .lil-gui { 
            --background-color: rgba(20, 25, 40, 0.4);
            --text-color: rgba(255, 255, 255, 0.95);
            --title-background-color: transparent;
            --widget-color: rgba(255, 255, 255, 0.1);
            --hover-color: rgba(255, 255, 255, 0.2);
            --focus-color: rgba(255, 255, 255, 0.3);
            --number-color: #a5b4fc;
            --string-color: #6ee7b7;
            
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            
            border-radius: 24px !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            border-top: 1px solid rgba(255, 255, 255, 0.2) !important;
            border-bottom: 1px solid rgba(0, 0, 0, 0.2) !important;
            border-left: none !important;
            
            box-shadow: 
                0 10px 40px rgba(0, 0, 0, 0.4),
                inset 0 0 0 1px rgba(255, 255, 255, 0.05) !important;
                
            padding-bottom: 15px;
        }
        
        .lil-gui .title {
            height: 40px;
            line-height: 40px;
            font-size: 14px;
            font-weight: 500;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: #a5b4fc; 
            text-shadow: 0 0 15px rgba(165, 180, 252, 0.4);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            background: transparent;
            text-align: center;
        }

        .lil-gui .children {
            padding: 10px;
        }
        
        .lil-gui.autoPlace {
            top: 30px !important;
            right: 20px !important;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1rem;
            z-index: 20;
            transition: opacity 1s ease;
            text-align: center;
            width: 80%;
            text-shadow: 0 0 20px rgba(255,255,255,0.5);
            font-weight: 300;
            letter-spacing: 3px;
        }

        .status-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            background-color: #fb7185; 
            margin-right: 10px;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(251, 113, 133, 0.5);
            vertical-align: middle;
            transition: all 0.5s ease;
            position: relative;
        }
        
        .status-dot::after {
            content: '';
            position: absolute;
            top: -4px;
            left: -4px;
            right: -4px;
            bottom: -4px;
            border-radius: 50%;
            border: 1px solid currentColor;
            opacity: 0.3;
            animation: pulse 2s infinite;
        }

        .status-active { background-color: #4ade80; box-shadow: 0 0 15px rgba(74, 222, 128, 0.6); color: #4ade80; }
        .status-inactive { background-color: #94a3b8; box-shadow: none; color: #94a3b8; }
        
        @keyframes pulse {
            0% { transform: scale(0.8); opacity: 0.5; }
            100% { transform: scale(1.5); opacity: 0; }
        }
        
        .divider {
            margin-top: 16px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 12px;
        }

        /* --- æ‰‹æ©Ÿç‰ˆéŸ¿æ‡‰å¼å„ªåŒ– (å°æ–¼ 600px) --- */
        @media (max-width: 600px) {
            #ui-layer {
                /* æ‰‹æ©Ÿç‰ˆï¼šå®Œç¾ç½®ä¸­é ä¸‹ */
                left: 50%;
                transform: translateX(-50%);
                
                /* åº•éƒ¨å®‰å…¨è·é›¢ */
                bottom: 20px; 
                bottom: calc(20px + env(safe-area-inset-bottom));
                
                width: 92%; /* å¯¬åº¦ç¨å¾®æ’é–‹ */
                padding: 15px;            
                border-radius: 16px;
            }
            
            #ui-layer h1 {
                font-size: 1.2rem;
                margin-bottom: 8px;
                padding-bottom: 8px;
            }
            
            .social-btn {
                width: 30px;
                height: 30px;
                font-size: 1rem;
            }
            
            .social-row {
                margin-bottom: 10px;
                gap: 8px;
            }
            
            /* ä¿®æ­£ï¼šé‡å°æ‰‹æ©Ÿç‰ˆæŒ‰éˆ•é€²è¡Œç¸®å°èˆ‡æ’ç‰ˆèª¿æ•´ï¼Œç¢ºä¿å–®è¡Œé¡¯ç¤º */
            .ui-footer-row {
                flex-wrap: nowrap; /* å¼·åˆ¶ä¸æ›è¡Œ */
                gap: 4px; /* ç¸®å°é–“è· */
                justify-content: space-between; /* å‡å‹»åˆ†ä½ˆ */
            }

            .reset-btn, .mode-btn {
                font-size: 10px; /* ç¸®å°å­—é«” (ç´„ 0.65rem) */
                padding: 6px 4px; /* ç¸®å°å…§è· */
                letter-spacing: 0; /* æ¸›å°‘å­—è· */
                flex-shrink: 1; /* å…è¨±ç©ºé–“ä¸è¶³æ™‚ç¸®å° */
                min-width: 0;
            }

            /* ç¢ºä¿åœ–ç¤ºèˆ‡æ–‡å­—çš„é–“è·ä¹Ÿç¸®å° */
            .reset-btn i, .mode-btn i {
                margin-right: 2px;
            }

            /* éŸ³æ¨‚æŒ‰éˆ•åªæœ‰åœ–ç¤ºï¼Œä¸éœ€è¦ç¸®å¤ªå¤šï¼Œä½†é˜²æ­¢è¢«æ“ å£“ */
            #btn-music {
                flex-shrink: 0;
                padding: 6px 8px;
            }
            
            .divider {
                margin-top: 10px;
                padding-top: 8px;
            }

            /* --- Control Center (lil-gui) æ‰‹æ©Ÿç‰ˆå„ªåŒ– --- */
            .lil-gui.autoPlace {
                top: 10px !important;
                right: 10px !important;
                max-width: calc(100vw - 20px) !important;
                width: auto !important;
            }
            
            .lil-gui {
                --width: 260px;
                font-size: 13px;
                --widget-height: 28px; /* å›å¾©åŸæœ¬çš„è§¸æ§å€ */
                max-height: 50vh;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch; 
            }
            
            .lil-gui .title {
                height: 36px;
                line-height: 36px;
                font-size: 12px;
            }
            
            .lil-gui .children {
                padding: 5px;
            }
        }
    </style>

    <!-- å¼•å…¥ MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- Import Map for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loading">Initializing Quantum Field...<br><span style="font-size:0.7em; opacity:0.6; letter-spacing: 1px;">Awaiting Input</span></div>

    <!-- åŠ å…¥éŸ³è¨Šå…ƒç´  (å·²ç§»é™¤ loop å±¬æ€§) -->
    <audio id="bg-music">
        <source src="Artlist Musical Logos - Tribal Rhythm.mp3" type="audio/mpeg">
    </audio>

    <div id="ui-layer">
        <h1>ASIAN BOY VISION</h1>
        
        <!-- ç¤¾ç¾¤æŒ‰éˆ• -->
        <div class="social-row">
            <a href="https://www.instagram.com/asian_boy_neo" target="_blank" class="social-btn" title="Instagram">
                <i class="fab fa-instagram"></i>
            </a>
            <a href="https://www.youtube.com/@asian_boy_neo" target="_blank" class="social-btn" title="YouTube">
                <i class="fab fa-youtube"></i>
            </a>
            <a href="https://www.threads.com/@asian_boy_neo?hl=zh-tw" target="_blank" class="social-btn" title="Threads">
                <i class="fa-brands fa-threads"></i>
            </a>
            <a href="https://ko-fi.com/asianboyneo" target="_blank" class="social-btn" title="Ko-fi">
                <i class="fa-solid fa-mug-hot"></i>
            </a>
        </div>
        
        <!-- åº•éƒ¨å€åŸŸï¼šç…§ç‰‡æ¨¡å¼åˆ‡æ› (å·¦) + Explosion æŒ‰éˆ• + Reset æŒ‰éˆ• + éŸ³æ¨‚ (æœ€å³) -->
        <div class="ui-footer-row">
            <button id="btn-mode-toggle" class="mode-btn">
                <i class="fas fa-image"></i> Photo Mode
            </button>
            
            <!-- Explosion æŒ‰éˆ• (å·²ç§»è‡³ Reset å·¦é‚Š) -->
            <button id="btn-explode" class="reset-btn" title="Hold to Sustain Explosion">
                <i class="fas fa-bomb"></i> Explosion
            </button>

            <!-- Reset æŒ‰éˆ• (å·²ç§»è‡³ Explosion å³é‚Š) -->
            <button id="btn-reset" class="reset-btn" title="Reset View">
                <i class="fas fa-sync-alt"></i> Reset
            </button>

            <!-- éŸ³æ¨‚æ§åˆ¶æŒ‰éˆ• (ä¿æŒæœ€å³é‚Š) -->
            <button id="btn-music" class="reset-btn" title="Toggle Music">
                <i class="fas fa-volume-mute"></i>
            </button>
        </div>
    </div>

    <!-- éš±è—çš„æ–‡ä»¶ä¸Šå‚³è¼¸å…¥æ¡† -->
    <input type="file" id="file-input" style="display: none;" accept="image/*">

    <video id="video-input" playsinline muted autoplay></video>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // ç§»é™¤ Firebase ç›¸é—œå¼•ç”¨

        // --- å…¨å±€è®Šé‡ ---
        let scene, camera, renderer, composer, controls;
        let particles, geometry, material;
        let imagePlane; // ç”¨æ–¼ç…§ç‰‡æ¨¡å¼çš„å¹³é¢ Mesh
        // æ–°å¢ï¼šæ™‚é˜ç‰©ä»¶ï¼Œç”¨æ–¼è¨ˆç®—æ™‚é–“å·®ï¼Œè§£æ±ºä¸åŒè£ç½®é€Ÿåº¦ä¸ä¸€è‡´å•é¡Œ
        const clock = new THREE.Clock(); 
        let time = 0;
        let currentImageData = null; 
        
        let cameraUtils; 
        let isCameraActive = false; 
        
        // é–‹å ´å‹•ç•«ç‹€æ…‹æ——æ¨™
        let isIntroAnimation = true;
        
        // ç…§ç‰‡æ¨¡å¼ç‹€æ…‹æ——æ¨™
        let isPhotoMode = false;

        // æ‰‹å‹•çˆ†ç ´è®Šæ•¸
        let manualExplosionStrength = 0;
        // çˆ†ç ´é•·æŒ‰ç‹€æ…‹
        let isHoldingExplode = false;

        // é è¨­åœ–ç‰‡è·¯å¾‘
        const DEFAULT_IMAGE_PATH = '287069905_564270111773809_6459526836966162411_n.jpg';

        // --- æ’­æ”¾éŸ³æ¨‚çš„è¼”åŠ©å‡½å¼ ---
        function playMusic(restart = false) {
            const audio = document.getElementById('bg-music');
            const musicBtn = document.getElementById('btn-music');
            
            if (audio) {
                if (restart) {
                    audio.currentTime = 0;
                }
                
                // å˜—è©¦æ’­æ”¾
                const playPromise = audio.play();
                
                if (playPromise !== undefined) {
                    playPromise.then(_ => {
                        // æ’­æ”¾æˆåŠŸ
                        if (musicBtn) {
                            musicBtn.innerHTML = '<i class="fas fa-music"></i>';
                            musicBtn.classList.add('active-music');
                        }
                    })
                    .catch(error => {
                        // æ’­æ”¾å¤±æ•— (é€šå¸¸æ˜¯å› ç‚ºæ²’æœ‰ä½¿ç”¨è€…äº’å‹•)
                        console.log("Autoplay prevented:", error);
                        // ä¿æŒéœéŸ³åœ–ç¤º
                        if (musicBtn) {
                            musicBtn.innerHTML = '<i class="fas fa-volume-mute"></i>';
                            musicBtn.classList.remove('active-music');
                        }
                    });
                }
            }
        }

        // --- æ–°å¢ï¼šéš¨æ©Ÿè¨­å®šç›¸æ©Ÿç™¼å°„ä½ç½®çš„è¼”åŠ©å‡½å¼ ---
        function setRandomLaunchPosition() {
            // è¨­å®šä¸€å€‹æ¥µé çš„åŠå¾‘ç¯„åœ (ä¾‹å¦‚ 2000~3000)
            const r = 2000 + Math.random() * 1000;
            
            // çƒé¢åº§æ¨™éš¨æ©Ÿå–é»
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            
            // è½‰æ›ç‚ºç¬›å¡å…’åº§æ¨™ (X, Y, Z)
            camera.position.x = r * Math.sin(phi) * Math.cos(theta);
            camera.position.y = r * Math.sin(phi) * Math.sin(theta);
            camera.position.z = r * Math.cos(phi);
            
            // ç¢ºä¿ç›¸æ©Ÿä¸€é–‹å§‹å°±çœ‹è‘—ä¸­å¿ƒï¼Œé¿å…è¿·å¤±æ–¹å‘
            camera.lookAt(0, 0, 0);
        }

        const params = {
            count: 80000,          
            size: 306,             
            opacity: 1.0,          
            bloomStrength: 3.0,    
            depthStrength: 60.0,   
            floating: true,       
            floatSpeed: 3.0,       
            
            toggleCamera: function() {
                if (!cameraUtils) return;

                const statusDot = document.getElementById('cam-status');
                const statusText = document.getElementById('status-text');
                const instructions = document.getElementById('gesture-instructions');

                if (isCameraActive) {
                    cameraUtils.stop();
                    isCameraActive = false;
                    handPresent = false; 
                    
                    if(statusDot) statusDot.className = 'status-dot status-inactive';
                    if(statusText) statusText.textContent = "Sensors Offline";
                    
                    if(instructions) instructions.style.display = 'none';
                } else {
                    cameraUtils.start().then(() => {
                        isCameraActive = true;
                        if(statusDot) statusDot.className = 'status-dot status-active';
                        if(statusText) statusText.textContent = "Sensors Active";
                        
                        if(instructions) instructions.style.display = 'block';
                    });
                    if(statusDot) statusDot.className = 'status-dot'; 
                    if(statusText) statusText.textContent = "Initializing...";
                }
            },
            uploadPhoto: function() {
                document.getElementById('file-input').click();
            },
            resetView: function() {
                // é‡ç½®æ—‹è½‰ç›®æ¨™è®Šæ•¸
                targetRotationX = 0;
                targetRotationY = 0;
                targetCameraZ = 150;
                
                // é‡ç½®ç²’å­æœ¬èº«çš„æ—‹è½‰è§’åº¦
                if (particles) particles.rotation.set(0, 0, 0);

                // --- è§¸ç™¼é–‹å ´ç©¿æ¢­ç‰¹æ•ˆé‚è¼¯ ---
                // 1. è¨­å®šéš¨æ©Ÿç™¼å°„ä½ç½® (æ³¨æ„ï¼šä¸å‘¼å« controls.reset())
                setRandomLaunchPosition();
                
                // 2. æš«æ™‚é–å®šæ§åˆ¶å™¨
                controls.enabled = false;
                // ç¢ºä¿ç›®æ¨™é»æ­¸é›¶
                controls.target.set(0, 0, 0);
                
                // 3. é–‹å•Ÿå‹•ç•«æ——æ¨™
                isIntroAnimation = true;

                // 4. é‡æ’­éŸ³æ¨‚ (å› ç‚ºé€™æ˜¯ä½¿ç”¨è€…é»æ“Šè§¸ç™¼çš„ï¼Œæ‰€ä»¥ç€è¦½å™¨æœƒå…è¨±æ’­æ”¾)
                playMusic(true);
            }
        };
        
        let handPresent = false;
        let targetRotationX = 0;
        let targetRotationY = 0;
        let targetCameraZ = 150; 
        let pinchStrength = 0;

        init();
        // initFirebase(); // å·²ç§»é™¤ Firebase çµ±è¨ˆåŠŸèƒ½
        initUI();
        initMediaPipe();
        initFileUpload();
        animate();

        function init() {
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020205); 
            scene.fog = new THREE.FogExp2(0x020205, 0.0015);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 20000); 
            
            // ä¿®æ­£ï¼šå…ˆè¨­å®šåˆ°æ¨™æº–ä½ç½® (0, 0, 150)ï¼Œè®“ Controls è¨˜ä½é€™å€‹æ˜¯ "Home"
            camera.position.set(0, 0, 150);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ 
                antialias: false, 
                powerPreference: "high-performance",
                alpha: false
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
            renderer.toneMapping = THREE.ReinhardToneMapping;
            container.appendChild(renderer.domElement);

            loadDefaultImage();

            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth / window.innerHeight / 2, window.innerHeight / 2), 
                1.5, 0.4, 0.85
            );
            bloomPass.strength = params.bloomStrength;
            bloomPass.radius = 0.5;
            bloomPass.threshold = 0.1; 

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
            composer.bloomPass = bloomPass;

            // åˆå§‹åŒ– OrbitControls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = false; 
            controls.maxPolarAngle = Math.PI * 0.75;
            controls.minPolarAngle = Math.PI * 0.25;
            controls.enableTouch = true;
            
            // å„²å­˜ç›®å‰ç‹€æ…‹ (150) ä½œç‚ºé è¨­é»
            controls.saveState();

            // é–‹å ´å‹•ç•«ï¼šæ‰‹å‹•å°‡ç›¸æ©Ÿç§»åˆ°éš¨æ©Ÿé æ–¹
            setRandomLaunchPosition();
            
            // é–‹å ´å‹•ç•«æœŸé–“æš«åœæ§åˆ¶
            controls.enabled = false;

            window.addEventListener('resize', onWindowResize);
            
            setTimeout(() => {
                const loading = document.getElementById('loading');
                if(loading) loading.style.opacity = 0;
            }, 1500);

            // å˜—è©¦é–‹å ´æ’­æ”¾éŸ³æ¨‚ (å¯èƒ½æœƒè¢«é˜»æ“‹)
            playMusic();
        }

        function loadDefaultImage() {
            const statusText = document.getElementById('status-text');
            if(statusText) statusText.textContent = "Loading Default Image...";

            const img = new Image();
            img.crossOrigin = "Anonymous"; 
            img.onload = function() {
                console.log("Default image loaded successfully.");
                processImageToParticles(img, true); 
                if(statusText) statusText.textContent = "Camera Standby";
            };
            img.onerror = function() {
                console.warn("Could not load default image. Falling back to default galaxy.");
                generateParticles(params.count); 
                if(statusText) statusText.textContent = "Camera Standby";
            };
            img.src = DEFAULT_IMAGE_PATH;
        }

        function processImageToParticles(img, isInit = false) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            const maxSize = 400; 
            let w = img.width;
            let h = img.height;
            if (w > h && w > maxSize) {
                h = Math.round(h * (maxSize / w));
                w = maxSize;
            } else if (h > maxSize) {
                w = Math.round(w * (maxSize / h));
                h = maxSize;
            }

            canvas.width = w;
            canvas.height = h;
            ctx.drawImage(img, 0, 0, w, h);

            const imageData = ctx.getImageData(0, 0, w, h);
            
            currentImageData = {
                width: w,
                height: h,
                data: imageData.data,
                aspectRatio: img.width / img.height
            };

            generateParticles(params.count, currentImageData);

            // --- æ–°å¢ï¼šå‰µå»ºç…§ç‰‡æ¨¡å¼ç”¨çš„ Plane Mesh ---
            const displayWidth = 100;
            const displayHeight = 100;
            let finalWidth, finalHeight;
            if (currentImageData.aspectRatio >= 1) {
                finalWidth = displayWidth;
                finalHeight = displayWidth / currentImageData.aspectRatio;
            } else {
                finalWidth = displayHeight * currentImageData.aspectRatio;
                finalHeight = displayHeight;
            }

            // æ¸…é™¤èˆŠçš„ imageMesh
            if (imagePlane) {
                scene.remove(imagePlane);
                imagePlane.geometry.dispose();
                if(imagePlane.material.map) imagePlane.material.map.dispose();
                imagePlane.material.dispose();
            }

            const texture = new THREE.Texture(img);
            texture.needsUpdate = true;
            texture.colorSpace = THREE.SRGBColorSpace; 

            const planeGeometry = new THREE.PlaneGeometry(finalWidth, finalHeight);
            const planeMaterial = new THREE.MeshBasicMaterial({ 
                map: texture,
                transparent: true,
                side: THREE.DoubleSide
            });

            imagePlane = new THREE.Mesh(planeGeometry, planeMaterial);
            imagePlane.visible = isPhotoMode; // æ ¹æ“šç›®å‰æ¨¡å¼æ±ºå®šæ˜¯å¦é¡¯ç¤º
            scene.add(imagePlane);

            // æ›´æ–°ç²’å­å¯è¦‹åº¦ (æ ¹æ“šæ˜¯å¦ç‚º Photo Mode)
            if(particles) particles.visible = !isPhotoMode;
            
            if (!isInit) {
                // ä¸Šå‚³åœ–ç‰‡å¾Œï¼Œä½¿ç”¨éš¨æ©Ÿè§’åº¦ç™¼å°„
                setRandomLaunchPosition();
                
                // é‡ç½®ç²’å­æ—‹è½‰ï¼Œè®“æ–°åœ–ç‰‡å¾æ­£é¢é–‹å§‹
                if (particles) particles.rotation.set(0, 0, 0);
                targetRotationX = 0;
                targetRotationY = 0;

                // ä¿®æ­£ï¼šä¸å‘¼å« resetï¼Œåªé–å®šä¸¦æ­¸é›¶ç›®æ¨™
                controls.enabled = false; 
                controls.target.set(0, 0, 0);
                
                isIntroAnimation = true; // é‡æ–°å•Ÿå‹•ç©¿æ¢­å‹•ç•«æ——æ¨™

                // ä¸Šå‚³æ–°åœ–ç‰‡æ™‚ä¹Ÿé‡æ’­éŸ³æ¨‚
                playMusic(true);
            }
        }

        function initUI() {
            // ç¶å®šå·¦ä¸‹è§’é¢æ¿çš„ Reset æŒ‰éˆ•
            const resetBtn = document.getElementById('btn-reset');
            
            // --- Reset é‚„åŸç‚ºå–®ç´”é»æ“Šé‚è¼¯ ---
            if (resetBtn) {
                resetBtn.addEventListener('click', (e) => {
                    e.preventDefault(); // é˜²æ­¢æŒ‰éˆ•ç„¦é»æ®˜ç•™
                    params.resetView();
                    resetBtn.blur();
                });
            }

            // ç¶å®š Explosion æŒ‰éˆ•
            const explodeBtn = document.getElementById('btn-explode');
            
            // é•·æŒ‰é–‹å§‹
            const startExplode = (e) => {
                if(e.cancelable) e.preventDefault(); 
                
                // å¦‚æœåœ¨ç…§ç‰‡æ¨¡å¼ï¼Œè‡ªå‹•åˆ‡å›ç²’å­æ¨¡å¼
                if(isPhotoMode) {
                    const modeBtn = document.getElementById('btn-mode-toggle');
                    if(modeBtn) modeBtn.click();
                }
                
                isHoldingExplode = true;
            };

            // é•·æŒ‰çµæŸ
            const endExplode = () => {
                isHoldingExplode = false;
                if(explodeBtn) explodeBtn.blur();
            };

            if (explodeBtn) {
                // ç¶å®šæŒ‰ä¸‹äº‹ä»¶ (æ»‘é¼ /è§¸æ§)
                explodeBtn.addEventListener('mousedown', startExplode);
                explodeBtn.addEventListener('touchstart', startExplode, {passive: false});
                
                // ç¶å®šæ”¾é–‹äº‹ä»¶ (å…¨åŸŸç›£è½ï¼Œé˜²æ­¢æ»‘å‡ºæŒ‰éˆ•æ”¾é–‹ç„¡æ•ˆ)
                window.addEventListener('mouseup', endExplode);
                window.addEventListener('touchend', endExplode);
            }

            // --- æ–°å¢ï¼šç¶å®šéŸ³æ¨‚æŒ‰éˆ• ---
            const musicBtn = document.getElementById('btn-music');
            const audio = document.getElementById('bg-music');

            // ç›£è½éŸ³æ¨‚çµæŸäº‹ä»¶ï¼šç•¶éŸ³æ¨‚æ’­å®Œæ™‚ï¼Œæ›´æ–°æŒ‰éˆ•ç‹€æ…‹
            if (audio) {
                audio.addEventListener('ended', () => {
                    if (musicBtn) {
                        musicBtn.innerHTML = '<i class="fas fa-volume-mute"></i>';
                        musicBtn.classList.remove('active-music');
                    }
                });
            }

            if (musicBtn) {
                musicBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (audio) {
                        if (audio.paused) {
                            playMusic(); // æ’­æ”¾
                        } else {
                            audio.pause();
                            musicBtn.innerHTML = '<i class="fas fa-volume-mute"></i>';
                            musicBtn.classList.remove('active-music');
                        }
                    }
                    musicBtn.blur();
                });
            }

            // --- æ–°å¢ï¼šç¶å®šç…§ç‰‡æ¨¡å¼åˆ‡æ›æŒ‰éˆ• ---
            const modeBtn = document.getElementById('btn-mode-toggle');
            if (modeBtn) {
                modeBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    isPhotoMode = !isPhotoMode;
                    
                    if (isPhotoMode) {
                        // ä¿®æ”¹è™•ï¼šåˆ‡æ›æˆç²’å­æ¨¡å¼çš„æŒ‰éˆ•æ–‡å­—
                        modeBtn.innerHTML = '<i class="fas fa-cubes"></i> Particle Mode';
                        modeBtn.classList.add('active-photo');
                        
                        // åˆ‡æ›ç‚ºç…§ç‰‡æ¨¡å¼ï¼šéš±è—ç²’å­ï¼Œé¡¯ç¤ºç…§ç‰‡ï¼Œæ¸›å¼±ç™¼å…‰
                        if (particles) particles.visible = false;
                        if (imagePlane) imagePlane.visible = true;
                        if (composer.bloomPass) composer.bloomPass.strength = 0.2; // å¾®å¾®ç™¼å…‰å³å¯ï¼Œå¤ªå¼·æœƒéæ›
                    } else {
                        // ä¿®æ”¹è™•ï¼šåˆ‡æ›æˆç…§ç‰‡æ¨¡å¼çš„æŒ‰éˆ•æ–‡å­—
                        modeBtn.innerHTML = '<i class="fas fa-image"></i> Photo Mode';
                        modeBtn.classList.remove('active-photo');
                        
                        // åˆ‡æ›å›ç²’å­æ¨¡å¼ï¼šé¡¯ç¤ºç²’å­ï¼Œéš±è—ç…§ç‰‡ï¼Œæ¢å¾©ç™¼å…‰
                        if (particles) particles.visible = true;
                        if (imagePlane) imagePlane.visible = false;
                        if (composer.bloomPass) composer.bloomPass.strength = params.bloomStrength;
                    }
                    
                    modeBtn.blur();
                });
            }

            const gui = new GUI({ title: 'Control Center' }); 
            if (window.innerWidth < 600) gui.close();

            const folder1 = gui.addFolder('Input Source');
            folder1.add(params, 'toggleCamera').name('ğŸ‘ï¸ Hand Tracking');
            folder1.add(params, 'uploadPhoto').name('ğŸ“· Upload Image');
            
            folder1.add(params, 'floating').name('ğŸŒŠ Auto Float');
            folder1.add(params, 'floatSpeed', 0.1, 5.0).name('Float Speed');
            
            folder1.add(params, 'depthStrength', 0, 100).name('3D Depth').onChange(val => {
                if(currentImageData) generateParticles(params.count, currentImageData);
            });

            const folder2 = gui.addFolder('Particle System');
            folder2.add(params, 'count', 5000, 80000, 5000).name('Density').onFinishChange(val => {
                generateParticles(val, currentImageData);
            });
            
            folder2.add(params, 'size', 10, 1000).name('Size').onChange(val => {
                if(material) material.uniforms.uSize.value = val;
            });

            folder2.add(params, 'opacity', 0.1, 1.0).name('Opacity').onChange(val => {
                if(material) material.uniforms.uOpacity.value = val;
            });

            folder2.add(params, 'bloomStrength', 0, 3).name('Glow Intensity').onChange(val => {
                params.bloomStrength = val; // æ›´æ–° params æ•¸å€¼
                // åªæœ‰åœ¨éç…§ç‰‡æ¨¡å¼ä¸‹æ‰å³æ™‚æ›´æ–° bloom å¼·åº¦
                if (!isPhotoMode && composer.bloomPass) {
                    composer.bloomPass.strength = val;
                }
            });
        }

        function initFileUpload() {
            const fileInput = document.getElementById('file-input');
            fileInput.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = function() {
                        processImageToParticles(img, false); 
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
                this.value = '';
            });
        }

        function generateParticles(count, imgData = null) {
            if (particles) {
                scene.remove(particles);
                particles.geometry.dispose();
            }

            geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const sizes = [];
            const randomness = [];

            const displayWidth = 100;
            const displayHeight = 100;

            if (imgData) {
                let finalWidth, finalHeight;
                if (imgData.aspectRatio >= 1) {
                    finalWidth = displayWidth;
                    finalHeight = displayWidth / imgData.aspectRatio;
                } else {
                    finalWidth = displayHeight * imgData.aspectRatio;
                    finalHeight = displayHeight;
                }

                const data = imgData.data;
                const w = imgData.width;
                const h = imgData.height;

                for (let i = 0; i < count; i++) {
                    const px = Math.floor(Math.random() * w);
                    const py = Math.floor(Math.random() * h);
                    
                    const index = (py * w + px) * 4;
                    
                    const r = data[index] / 255;
                    const g = data[index + 1] / 255;
                    const b = data[index + 2] / 255;
                    const a = data[index + 3];

                    if (a < 20 || (r+g+b) < 0.05) {
                         colors.push(0, 0, 0); 
                    } else {
                        colors.push(r, g, b);
                    }

                    const u = (px / w) - 0.5;
                    const v = (py / h) - 0.5;

                    const x = u * finalWidth;
                    const y = -v * finalHeight; 

                    const brightness = 0.299 * r + 0.587 * g + 0.114 * b;
                    const z = brightness * params.depthStrength; 

                    positions.push(x, y, z);
                    sizes.push(Math.random() * 0.5 + 0.5); 
                    randomness.push(Math.random());
                }

            } else {
                const galaxyColor1 = new THREE.Color('#00ffff');
                const galaxyColor2 = new THREE.Color('#ff00ff');

                for (let i = 0; i < count; i++) {
                    const r = Math.random() * 50;
                    const spinAngle = r * 0.2;
                    const branchAngle = (i % 3) * ((Math.PI * 2) / 3);
                    
                    const randomX = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1) * (10 - r * 0.1);
                    const randomY = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1) * (10 - r * 0.1);
                    const randomZ = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1) * (10 - r * 0.1);

                    const x = Math.cos(spinAngle + branchAngle) * r + randomX;
                    const y = (Math.random() - 0.5) * (r * 0.2) + randomY; 
                    const z = Math.sin(spinAngle + branchAngle) * r + randomZ;

                    positions.push(x, y, z);

                    const mixedColor = galaxyColor1.clone().lerp(galaxyColor2, r / 50);
                    colors.push(mixedColor.r, mixedColor.g, mixedColor.b);

                    sizes.push(Math.random());
                    randomness.push(Math.random());
                }
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            geometry.setAttribute('randomness', new THREE.Float32BufferAttribute(randomness, 1));

            if (!material) {
                material = new THREE.ShaderMaterial({
                    uniforms: {
                        uTime: { value: 0 },
                        uPixelRatio: { value: renderer.getPixelRatio() },
                        uSize: { value: params.size },
                        uOpacity: { value: params.opacity }, 
                        uPinch: { value: 0 }
                    },
                    vertexShader: `
                        uniform float uTime;
                        uniform float uPixelRatio;
                        uniform float uSize;
                        uniform float uPinch;
                        
                        attribute float size;
                        attribute float randomness;
                        attribute vec3 color;
                        
                        varying vec3 vColor;

                        void main() {
                            vec3 pos = position;
                            
                            // ä¿æŒå‘¼å¸æ•ˆæœ
                            float wave = sin(pos.x * 0.1 + uTime) * 0.5 + cos(pos.y * 0.1 + uTime) * 0.5;
                            pos.z += wave * 0.5; 

                            vec3 dir = normalize(pos);
                            if (length(pos) < 0.1) dir = vec3(0.0, 0.0, 1.0);
                            
                            // --- ä¿®æ”¹è™•ï¼šå¤§å¹…å¢å¼·çˆ†ç ´æ•ˆæœ ---
                            // åŸæœ¬åªæœ‰ * 30.0ï¼Œç¾åœ¨æ”¹ç‚º * 200.0 ä¸¦åŠ å…¥éš¨æ©Ÿæ€§ (randomness)
                            // é€™æ¨£ç²’å­æœƒç‚¸å¾—éå¸¸é–‹ï¼Œä¸”å±¤æ¬¡åˆ†æ˜
                            float explosionDist = uPinch * (50.0 + randomness * 300.0);
                            pos += dir * explosionDist;
                            
                            // ä¿æŒéš¨æ©Ÿé–ƒçˆ
                            pos.x += sin(uTime * 5.0 + randomness * 100.0) * 0.1;
                            pos.y += cos(uTime * 5.0 + randomness * 100.0) * 0.1;

                            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                            
                            // --- ä¿®æ”¹è™•ï¼šå¢å¼·çˆ†ç ´æ™‚çš„ç²’å­å¤§å°è†¨è„¹ ---
                            // å°‡ 1.5 æ”¹ç‚º 5.0ï¼Œè®“çˆ†ç™¼æ™‚ç²’å­ç¬é–“è®Šå¤§è®Šäº®
                            gl_PointSize = (uSize * size * (1.0 + uPinch * 5.0)) * uPixelRatio * (1.0 / -mvPosition.z);
                            gl_PointSize = min(gl_PointSize, 500.0);

                            gl_Position = projectionMatrix * mvPosition;
                            
                            // çˆ†ç ´æ™‚ç¨å¾®å¢åŠ ä¸€é»äº®åº¦
                            vColor = color + vec3(uPinch * 0.8);
                        }
                    `,
                    fragmentShader: `
                        uniform float uOpacity; 
                        varying vec3 vColor;
                        
                        void main() {
                            vec2 xy = gl_PointCoord.xy - vec2(0.5);
                            float ll = length(xy);
                            if(ll > 0.5) discard;
                            
                            float alpha = (0.5 - ll) * 2.0;
                            alpha = pow(alpha, 2.0);

                            gl_FragColor = vec4(vColor, alpha * uOpacity);
                        }
                    `,
                    transparent: true,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending
                });
            }

            particles = new THREE.Points(geometry, material);
            // æ³¨æ„ï¼šé€™è£¡ä¸ç›´æ¥ add(particles)ï¼Œæ”¹ç‚ºæ ¹æ“šæ¨¡å¼åˆ¤æ–·
            particles.visible = !isPhotoMode; 
            scene.add(particles);
        }

        // --- MediaPipe ---
        function initMediaPipe() {
            const videoElement = document.getElementById('video-input');
            const statusDot = document.getElementById('cam-status');
            const statusText = document.getElementById('status-text');

            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1, 
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandsResults);

            cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
        }

        function onHandsResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handPresent = true;
                controls.autoRotate = false;

                const landmarks = results.multiHandLandmarks[0];
                
                const palmX = landmarks[9].x;
                const palmY = landmarks[9].y;
                targetRotationY = (palmX - 0.5) * 6; 
                targetRotationX = (palmY - 0.5) * 3;

                const wrist = landmarks[0];
                const middleKnuckle = landmarks[9];
                const handSize = Math.sqrt(
                    Math.pow(wrist.x - middleKnuckle.x, 2) + 
                    Math.pow(wrist.y - middleKnuckle.y, 2)
                );
                
                const minHand = 0.05; 
                const maxHand = 0.25; 
                const minZ = 50;      
                const maxZ = 300;     

                let normalizedSize = (handSize - minHand) / (maxHand - minHand);
                normalizedSize = Math.max(0, Math.min(1, normalizedSize));

                targetCameraZ = maxZ - (normalizedSize * (maxZ - minZ));

                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const distance = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) + 
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );

                const pinchThreshold = 0.12;
                if(distance < pinchThreshold) {
                    pinchStrength = Math.min(1, (pinchThreshold - distance) / pinchThreshold);
                } else {
                    pinchStrength = 0;
                }

            } else {
                handPresent = false;
                controls.autoRotate = false; 
                pinchStrength = Math.max(0, pinchStrength - 0.05);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            if(material) material.uniforms.uPixelRatio.value = renderer.getPixelRatio();
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // ç²å–å…©å¹€ä¹‹é–“çš„æ™‚é–“å·® (ç§’)
            const dt = clock.getDelta(); 
            // ç´¯åŠ æ™‚é–“çµ¦ Shader ä½¿ç”¨
            time += dt;

            // è™•ç†æ‰‹å‹•çˆ†ç ´çš„è¡°æ¸›èˆ‡ç¶­æŒ
            if (isHoldingExplode) {
                // é•·æŒ‰æ™‚ï¼Œå¼·åº¦ç¶­æŒåœ¨ 1.0 (ä½¿ç”¨æ™‚é–“å·®è®“éæ¸¡æ›´å¹³æ»‘)
                // åŸæœ¬æ˜¯æ¯å¹€ 0.1ï¼Œå‡è¨­ 60fpsï¼Œæ¯ç§’ç´„ 6.0
                // ä½¿ç”¨ lerp: current = current + (target - current) * (1 - exp(-decay * dt))
                const decay = 5.0;
                manualExplosionStrength += (1.0 - manualExplosionStrength) * (1.0 - Math.exp(-decay * dt));
            } else {
                // æ”¾é–‹æ™‚ï¼Œè¡°æ¸›
                if (manualExplosionStrength > 0) {
                    const decay = 5.0; // èª¿æ•´è¡°æ¸›é€Ÿåº¦
                    manualExplosionStrength *= Math.exp(-decay * dt);
                    if (manualExplosionStrength < 0.01) manualExplosionStrength = 0;
                }
            }

            if (material) {
                material.uniforms.uTime.value = time;
                // çµåˆæ‰‹å‹¢æåˆå¼·åº¦ èˆ‡ æ‰‹å‹•çˆ†ç ´å¼·åº¦
                let totalPinch = Math.max(pinchStrength, manualExplosionStrength);
                
                // å¹³æ»‘éæ¸¡ pinch å€¼ (åŒæ¨£æ”¹ç‚ºæ™‚é–“ç›¸é—œ)
                const pinchDecay = 5.0;
                material.uniforms.uPinch.value += (totalPinch - material.uniforms.uPinch.value) * (1.0 - Math.exp(-pinchDecay * dt));
            }

            // --- é–‹å ´ç©¿æ¢­å‹•ç•«é‚è¼¯ (ä¿®æ”¹ç‚ºå…¨æ–¹ä½ç§»å‹• + æ™‚é–“åŸºç¤) ---
            if (isIntroAnimation) {
                // ç›®æ¨™ä½ç½®
                const targetX = 0;
                const targetY = 0;
                const targetZ = 150;

                // --- é—œéµä¿®æ­£ï¼šå°‡é€Ÿåº¦æ”¹ç‚ºèˆ‡æ™‚é–“æ›é‰¤ ---
                // æˆ‘å€‘å¸Œæœ›çš„å‹•ç•«æ™‚é•·ç´„ç‚º 18-20 ç§’ã€‚
                // ä¹‹å‰çš„ 0.0055 æ˜¯åŸºæ–¼ 60fps çš„æ¯å¹€ä¿‚æ•¸ã€‚
                // å…¬å¼ï¼šfactor = 1 - Math.pow(1 - oldFactor, dt * 60)
                // é€™æ¨£ç„¡è«– fps å¤šå°‘ï¼Œæ•ˆæœéƒ½ç­‰åŒæ–¼ 60fps ä¸‹çš„ 0.0055
                const referenceFPS = 60;
                const baseFactor = 0.0055; 
                const timeAdjustedSpeed = 1 - Math.pow(1 - baseFactor, dt * referenceFPS);

                // å¹³æ»‘ç§»å‹•ç›¸æ©Ÿ (X, Y, Z éƒ½è¦å‹•)
                camera.position.x += (targetX - camera.position.x) * timeAdjustedSpeed;
                camera.position.y += (targetY - camera.position.y) * timeAdjustedSpeed;
                camera.position.z += (targetZ - camera.position.z) * timeAdjustedSpeed;
                
                // é£›è¡Œéç¨‹ä¸­æŒçºŒå°ç„¦ä¸­å¿ƒï¼Œç”¢ç”Ÿæ—‹è½‰æ•ˆæœ
                camera.lookAt(0, 0, 0);

                // è¨ˆç®—èˆ‡ç›®æ¨™é»çš„è·é›¢
                const dist = camera.position.distanceTo(new THREE.Vector3(targetX, targetY, targetZ));
                
                // æª¢æŸ¥æ˜¯å¦æ¥è¿‘ç›®æ¨™
                if (dist < 1.5) {
                    // 1. å¼·åˆ¶å°é½Šç›®æ¨™é»
                    camera.position.set(targetX, targetY, targetZ);
                    camera.lookAt(0, 0, 0);
                    
                    isIntroAnimation = false;
                    
                    // 2. å•Ÿç”¨æ§åˆ¶å™¨
                    controls.enabled = true;
                    
                    // 3. é—œéµä¿®æ­£ï¼šæš«æ™‚é—œé–‰é˜»å°¼ä¸¦æ›´æ–°ï¼Œä»¥æ¶ˆé™¤åˆ‡æ›ç¬é–“çš„æ…£æ€§è·³å‹•
                    controls.enableDamping = false;
                    controls.update(); 
                    controls.enableDamping = true; // æ¢å¾©é˜»å°¼
                }
            } else {
                // æ­£å¸¸æ¨¡å¼ä¸‹çš„æ§åˆ¶é‚è¼¯
                controls.update();

                if (handPresent) {
                    // æ‰‹å‹¢æ§åˆ¶ä¹ŸåŠ å…¥æ™‚é–“å·®ä¿®æ­£ï¼Œè®“æ“ä½œæ›´è·Ÿæ‰‹
                    const rotationSpeed = 3.0 * dt; // èª¿æ•´æ—‹è½‰é€Ÿåº¦ç³»æ•¸
                    const zoomSpeed = 2.0 * dt;

                    if(particles) {
                        particles.rotation.y += (targetRotationY - particles.rotation.y) * rotationSpeed;
                        particles.rotation.x += (targetRotationX - particles.rotation.x) * rotationSpeed;
                    }
                    camera.position.z += (targetCameraZ - camera.position.z) * zoomSpeed;
                } else {
                    if(particles && params.floating && !isPhotoMode) {
                        const speed = params.floatSpeed;
                        // è‡ªå‹•æ¼‚æµ®åŸæœ¬ç”¨ time (å·²æ˜¯ç´¯åŠ æ™‚é–“)ï¼Œæ‰€ä»¥é€™è£¡åªè¦ç¢ºä¿ time æ˜¯æ ¹æ“š dt ç´¯åŠ çš„å³å¯ (ä¸Šé¢å·²ä¿®æ­£)
                        
                        // ä½†æ—‹è½‰é˜»å°¼ä¹Ÿéœ€è¦æ™‚é–“ä¿®æ­£
                        const floatDamping = 1.0 * dt; 

                        const targetX = Math.sin(time * 0.3 * speed) * 0.15;
                        particles.rotation.x += (targetX - particles.rotation.x) * floatDamping;

                        const maxAngle = Math.PI / 4; 
                        const rawWave = (Math.sin(time * 0.5 * speed) + Math.cos(time * 0.2 * speed));
                        const targetY = (rawWave / 2) * maxAngle;
                        
                        particles.rotation.y += (targetY - particles.rotation.y) * floatDamping;
                    }
                }
            }

            composer.render();
        }
    </script>
</body>
</html>
