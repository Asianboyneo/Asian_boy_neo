<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <!-- iOS è¦–å£å„ªåŒ– -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Cosmic Particles (Unified Space Glass UI)</title>
    
    <!-- å¼•å…¥ Font Awesome åœ–æ¨™åº« -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">

    <!-- æ¨£å¼è¨­è¨ˆ -->
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #020205;
            /* ç¾ä»£ç„¡è¥¯ç·šå­—é«”ï¼Œä¹¾æ·¨å„ªé›… */
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            height: 100dvh; 
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #video-input {
            position: absolute;
            top: 0;
            left: 0;
            width: 1px;
            height: 1px;
            opacity: 0;
            pointer-events: none;
            z-index: -1;
        }

        /* --- å¤ªç©ºæ¯›ç»ç’ƒ UI æ ¸å¿ƒè¨­è¨ˆ (å·¦ä¸‹è§’é¢æ¿) --- */
        #ui-layer {
            position: absolute;
            bottom: 30px;
            left: 20px;
            max-width: 350px;
            width: calc(100% - 40px);
            
            color: rgba(255, 255, 255, 0.95);
            z-index: 10;
            pointer-events: none;
            
            /* å¤ªç©ºæ„Ÿæ·±è‰²åŠé€æ˜èƒŒæ™¯ */
            background: rgba(20, 25, 40, 0.4); 
            /* å¼·åŠ›æ¨¡ç³Šç”¢ç”Ÿæ·±åº¦æ„Ÿ */
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            
            padding: 24px;
            border-radius: 24px;
            
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            border-bottom: 1px solid rgba(0, 0, 0, 0.2);
            
            box-shadow: 
                0 10px 40px rgba(0, 0, 0, 0.4),
                inset 0 0 0 1px rgba(255, 255, 255, 0.05);
            
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        h1 {
            font-weight: 300;
            margin: 0 0 12px 0;
            font-size: 1.5rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            background: linear-gradient(120deg, #ffffff 0%, #a5b4fc 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            position: relative;
            padding-bottom: 12px;
        }
        
        h1::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 40px;
            height: 2px;
            background: rgba(165, 180, 252, 0.5);
            border-radius: 2px;
        }

        /* --- æ–°å¢ï¼šé¢æ¿å…§çš„ç¤¾ç¾¤æŒ‰éˆ•åˆ— --- */
        .social-row {
            display: flex;
            gap: 10px;
            margin-bottom: 15px; /* èˆ‡ä¸‹æ–¹å…§å®¹ä¿æŒè·é›¢ */
            pointer-events: auto; /* æ¢å¾©é»æ“Šäº‹ä»¶ */
        }

        .social-btn {
            color: rgba(255, 255, 255, 0.7);
            font-size: 1.1rem;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-decoration: none;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .social-btn:hover {
            color: #fff;
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(165, 180, 252, 0.3);
            border-color: rgba(165, 180, 252, 0.4);
        }

        /* å€‹åˆ¥å“ç‰Œé¡è‰²å¾®èª¿ (Hover æ™‚) */
        .social-btn:hover .fa-instagram { color: #e1306c; }
        .social-btn:hover .fa-youtube { color: #ff0000; }
        .social-btn:hover .fa-threads { color: #fff; } 
        .social-btn:hover .fa-mug-hot { color: #13C3FF; } 

        p {
            margin: 6px 0;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
            line-height: 1.6;
            font-weight: 400;
        }

        .highlight {
            color: #a5b4fc;
            font-weight: 500;
            text-shadow: 0 0 15px rgba(165, 180, 252, 0.4);
        }

        /* --- lil-gui å¤ªç©ºæ¯›ç»ç’ƒé¢¨æ ¼å®Œå…¨è¦†è“‹ --- */
        .lil-gui { 
            --background-color: rgba(20, 25, 40, 0.4);
            --text-color: rgba(255, 255, 255, 0.95);
            --title-background-color: transparent;
            --widget-color: rgba(255, 255, 255, 0.1);
            --hover-color: rgba(255, 255, 255, 0.2);
            --focus-color: rgba(255, 255, 255, 0.3);
            --number-color: #a5b4fc;
            --string-color: #6ee7b7;
            
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            
            border-radius: 24px !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            border-top: 1px solid rgba(255, 255, 255, 0.2) !important;
            border-bottom: 1px solid rgba(0, 0, 0, 0.2) !important;
            
            box-shadow: 
                0 10px 40px rgba(0, 0, 0, 0.4),
                inset 0 0 0 1px rgba(255, 255, 255, 0.05) !important;
                
            padding-bottom: 15px;
        }
        
        .lil-gui .title {
            height: 40px;
            line-height: 40px;
            font-size: 14px;
            font-weight: 500;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: #a5b4fc; 
            text-shadow: 0 0 15px rgba(165, 180, 252, 0.4);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            background: transparent;
            text-align: center;
        }

        .lil-gui .children {
            padding: 10px;
        }
        
        .lil-gui.autoPlace {
            top: 30px !important;
            right: 20px !important;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1rem;
            z-index: 20;
            transition: opacity 1s ease;
            text-align: center;
            width: 80%;
            text-shadow: 0 0 20px rgba(255,255,255,0.5);
            font-weight: 300;
            letter-spacing: 3px;
        }

        .status-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            background-color: #fb7185; 
            margin-right: 10px;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(251, 113, 133, 0.5);
            vertical-align: middle;
            transition: all 0.5s ease;
            position: relative;
        }
        
        .status-dot::after {
            content: '';
            position: absolute;
            top: -4px;
            left: -4px;
            right: -4px;
            bottom: -4px;
            border-radius: 50%;
            border: 1px solid currentColor;
            opacity: 0.3;
            animation: pulse 2s infinite;
        }

        .status-active { background-color: #4ade80; box-shadow: 0 0 15px rgba(74, 222, 128, 0.6); color: #4ade80; }
        .status-inactive { background-color: #94a3b8; box-shadow: none; color: #94a3b8; }
        
        @keyframes pulse {
            0% { transform: scale(0.8); opacity: 0.5; }
            100% { transform: scale(1.5); opacity: 0; }
        }
        
        .divider {
            margin-top: 16px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 12px;
        }

        .view-count-container {
            margin-top: 12px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.6);
            display: flex;
            align-items: center;
        }
        
        .view-count-num {
            color: #a5b4fc;
            font-weight: 600;
            margin-left: 6px;
            text-shadow: 0 0 8px rgba(165, 180, 252, 0.4);
        }

        /* --- æ‰‹æ©Ÿç‰ˆéŸ¿æ‡‰å¼å„ªåŒ– (Mobile Responsive) --- */
        @media (max-width: 600px) {
            /* 1. å·¦ä¸‹è§’ PARTICLE VISION é¢æ¿ (æ›´å°ã€æ›´é é‚Š) */
            #ui-layer {
                bottom: 20px;
                bottom: calc(20px + env(safe-area-inset-bottom)); /* é¿é–‹ Home Bar */
                left: 10px;
                width: calc(100% - 20px); /* æ»¿ç‰ˆä½†ç•™å°é‚Šè· */
                padding: 15px;            
                border-radius: 16px;
            }
            
            #ui-layer h1 {
                font-size: 1.2rem;
                margin-bottom: 8px;
                padding-bottom: 8px;
            }
            
            /* ç¤¾ç¾¤æŒ‰éˆ•åœ¨æ‰‹æ©Ÿä¸Šç¨å¾®ç¸®å° */
            .social-btn {
                width: 30px;
                height: 30px;
                font-size: 1rem;
            }
            
            .social-row {
                margin-bottom: 10px;
                gap: 8px;
            }
            
            #ui-layer p, .view-count-container {
                font-size: 0.8rem;
                margin: 4px 0;
            }
            
            .divider {
                margin-top: 10px;
                padding-top: 8px;
            }

            /* 2. å³ä¸Šè§’ Control Center (ç¸®å°å¯¬åº¦) */
            .lil-gui.autoPlace {
                top: 15px !important;
                right: 15px !important;
                max-width: 160px; /* å¼·åˆ¶æœ€å¤§å¯¬åº¦ */
            }
            
            .lil-gui {
                --width: 160px; /* è®Šæ•¸æ§åˆ¶å¯¬åº¦ */
                font-size: 11px; /* å­—é«”å†å°ä¸€é» */
            }
            
            .lil-gui .title {
                height: 28px;
                line-height: 28px;
                font-size: 11px;
            }
            
            .lil-gui .children {
                padding: 5px;
            }
        }
    </style>

    <!-- å¼•å…¥ MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- Import Map for Three.js and Firebase -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loading">Initializing Quantum Field...<br><span style="font-size:0.7em; opacity:0.6; letter-spacing: 1px;">Awaiting Input</span></div>

    <div id="ui-layer">
        <h1>ASIAN BOY VISION</h1>
        
        <!-- ç¤¾ç¾¤æŒ‰éˆ•æ•´åˆè‡³æ­¤ -->
        <div class="social-row">
            <a href="https://www.instagram.com/asian_boy_neo" target="_blank" class="social-btn" title="Instagram">
                <i class="fab fa-instagram"></i>
            </a>
            <a href="https://www.youtube.com/@asian_boy_neo" target="_blank" class="social-btn" title="YouTube">
                <i class="fab fa-youtube"></i>
            </a>
            <a href="https://www.threads.com/@asian_boy_neo?hl=zh-tw" target="_blank" class="social-btn" title="Threads">
                <i class="fa-brands fa-threads"></i>
            </a>
            <a href="https://ko-fi.com/asianboyneo" target="_blank" class="social-btn" title="Ko-fi">
                <i class="fa-solid fa-mug-hot"></i>
            </a>
        </div>

        <p><span id="cam-status" class="status-dot"></span><span id="status-text">Camera Standby</span></p>
        
        <!-- é è¨­éš±è—çš„æ“ä½œèªªæ˜ -->
        <div class="divider" id="gesture-instructions" style="display: none;">
            <p>ğŸ–ï¸ <span class="highlight">Move</span> to Rotate</p>
            <p>ğŸ‘‹ <span class="highlight">Distance</span> to Zoom</p>
            <p>ğŸ‘Œ <span class="highlight">Pinch</span> to Explode</p>
        </div>
        
        <!-- ç€è¦½æ¬¡æ•¸é¡¯ç¤º -->
        <div class="view-count-container">
            <i class="fas fa-eye" style="margin-right: 5px;"></i> Views: <span id="view-counter" class="view-count-num">---</span>
        </div>
    </div>

    <!-- éš±è—çš„æ–‡ä»¶ä¸Šå‚³è¼¸å…¥æ¡† -->
    <input type="file" id="file-input" style="display: none;" accept="image/*">

    <video id="video-input" playsinline muted autoplay></video>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, increment, collection, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- å…¨å±€è®Šé‡ ---
        let scene, camera, renderer, composer, controls;
        let particles, geometry, material;
        let time = 0;
        let currentImageData = null; 
        
        let cameraUtils; 
        let isCameraActive = false; 

        // é è¨­åœ–ç‰‡è·¯å¾‘
        const DEFAULT_IMAGE_PATH = '287069905_564270111773809_6459526836966162411_n.jpg';

        const params = {
            count: 80000,          
            size: 306,             
            opacity: 1.0,          
            bloomStrength: 3.0,    
            depthStrength: 60.0,   
            floating: true,       
            floatSpeed: 5.0,       
            
            toggleCamera: function() {
                if (!cameraUtils) return;

                const statusDot = document.getElementById('cam-status');
                const statusText = document.getElementById('status-text');
                const instructions = document.getElementById('gesture-instructions'); // ç²å–èªªæ˜å€å¡Š

                if (isCameraActive) {
                    cameraUtils.stop();
                    isCameraActive = false;
                    handPresent = false; 
                    
                    statusDot.className = 'status-dot status-inactive';
                    statusText.textContent = "Sensors Offline";
                    
                    // é—œé–‰ç›¸æ©Ÿæ™‚éš±è—èªªæ˜
                    if(instructions) instructions.style.display = 'none';
                } else {
                    cameraUtils.start().then(() => {
                        isCameraActive = true;
                        statusDot.className = 'status-dot status-active';
                        statusText.textContent = "Sensors Active";
                        
                        // é–‹å•Ÿç›¸æ©Ÿå¾Œé¡¯ç¤ºèªªæ˜
                        if(instructions) instructions.style.display = 'block';
                    });
                    statusDot.className = 'status-dot'; 
                    statusText.textContent = "Initializing...";
                }
            },
            uploadPhoto: function() {
                document.getElementById('file-input').click();
            },
            resetView: function() {
                camera.position.set(0, 0, 150);
                camera.lookAt(0, 0, 0);
                controls.reset();
                if (particles) particles.rotation.set(0, 0, 0);
                targetRotationX = 0;
                targetRotationY = 0;
                targetCameraZ = 150;
            }
        };
        
        let handPresent = false;
        let targetRotationX = 0;
        let targetRotationY = 0;
        let targetCameraZ = 150; 
        let pinchStrength = 0;

        init();
        initFirebase();
        initUI();
        initMediaPipe();
        initFileUpload();
        animate();

        function init() {
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020205); 
            scene.fog = new THREE.FogExp2(0x020205, 0.0015);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 2000);
            
            // ä¿®æ”¹ï¼šåˆå§‹ä½ç½®è¨­ç‚ºéå¸¸è¿‘ (Z=10) ç”¢ç”Ÿæ”¾å¤§æ•ˆæœ
            camera.position.set(0, 0, 10); 
            
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ 
                antialias: false, 
                powerPreference: "high-performance",
                alpha: false
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
            renderer.toneMapping = THREE.ReinhardToneMapping;
            container.appendChild(renderer.domElement);

            loadDefaultImage();

            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth / 2, window.innerHeight / 2), 
                1.5, 0.4, 0.85
            );
            bloomPass.strength = params.bloomStrength;
            bloomPass.radius = 0.5;
            bloomPass.threshold = 0.1; 

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
            composer.bloomPass = bloomPass;

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = false; 
            controls.maxPolarAngle = Math.PI * 0.75;
            controls.minPolarAngle = Math.PI * 0.25;
            controls.enableTouch = true;

            window.addEventListener('resize', onWindowResize);
            
            setTimeout(() => {
                const loading = document.getElementById('loading');
                if(loading) loading.style.opacity = 0;
            }, 1500);
        }

        async function initFirebase() {
            if (typeof __firebase_config === 'undefined') {
                console.warn("Firebase config not found. View counter disabled.");
                document.getElementById('view-counter').textContent = "Offline";
                return;
            }
            
            const firebaseConfig = JSON.parse(__firebase_config);
            const app = initializeApp(firebaseConfig);
            const auth = getAuth(app);
            const db = getFirestore(app);
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
                
                const statsCollection = collection(db, 'artifacts', appId, 'public', 'data', 'site_stats');
                const viewDocRef = doc(statsCollection, 'view_counter');

                const docSnap = await getDoc(viewDocRef);
                
                if (docSnap.exists()) {
                    await updateDoc(viewDocRef, { count: increment(1) });
                } else {
                    await setDoc(viewDocRef, { count: 1 });
                }

                onSnapshot(viewDocRef, (doc) => {
                    if (doc.exists()) {
                        const count = doc.data().count;
                        document.getElementById('view-counter').textContent = count.toLocaleString();
                    }
                }, (error) => {
                    console.error("Error watching views:", error);
                });

            } catch (error) {
                console.error("Firebase initialization error:", error);
                document.getElementById('view-counter').textContent = "Error";
            }
        }

        function loadDefaultImage() {
            const statusText = document.getElementById('status-text');
            if(statusText) statusText.textContent = "Loading Default Image...";

            const img = new Image();
            img.crossOrigin = "Anonymous"; 
            img.onload = function() {
                console.log("Default image loaded successfully.");
                processImageToParticles(img, true); // å‚³å…¥ true è¡¨ç¤ºæ˜¯åˆå§‹è¼‰å…¥
                if(statusText) statusText.textContent = "Camera Standby";
            };
            img.onerror = function() {
                console.warn("Could not load default image. Falling back to default galaxy.");
                generateParticles(params.count); 
                if(statusText) statusText.textContent = "Camera Standby";
            };
            img.src = DEFAULT_IMAGE_PATH;
        }

        // ä¿®æ”¹ï¼šåŠ å…¥ isInit åƒæ•¸
        function processImageToParticles(img, isInit = false) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            const maxSize = 400; 
            let w = img.width;
            let h = img.height;
            if (w > h && w > maxSize) {
                h = Math.round(h * (maxSize / w));
                w = maxSize;
            } else if (h > maxSize) {
                w = Math.round(w * (maxSize / h));
                h = maxSize;
            }

            canvas.width = w;
            canvas.height = h;
            ctx.drawImage(img, 0, 0, w, h);

            const imageData = ctx.getImageData(0, 0, w, h);
            
            currentImageData = {
                width: w,
                height: h,
                data: imageData.data,
                aspectRatio: img.width / img.height
            };

            generateParticles(params.count, currentImageData);
            
            // ä¿®æ”¹ï¼šåªæœ‰åœ¨éåˆå§‹è¼‰å…¥æ™‚æ‰å¼·åˆ¶é‡ç½®ç›¸æ©Ÿä½ç½®
            // é€™æ¨£å¯ä»¥ä¿ç•™åˆå§‹çš„ç¸®æ”¾å‹•ç•« (å¾ Z=10 å¹³æ»‘ç§»å‹•åˆ° Z=150)
            if (!isInit) {
                camera.position.set(0, 0, 150);
                controls.reset();
            }
        }

        function initUI() {
            const gui = new GUI({ title: 'Control Center' }); 
            if (window.innerWidth < 600) gui.close();

            const folder1 = gui.addFolder('Input Source');
            folder1.add(params, 'toggleCamera').name('ğŸ‘ï¸ Hand Tracking');
            folder1.add(params, 'uploadPhoto').name('ğŸ“· Upload Image');
            folder1.add(params, 'resetView').name('â†º Reset View');
            
            folder1.add(params, 'floating').name('ğŸŒŠ Auto Float');
            folder1.add(params, 'floatSpeed', 0.1, 5.0).name('Float Speed');
            
            folder1.add(params, 'depthStrength', 0, 100).name('3D Depth').onChange(val => {
                if(currentImageData) generateParticles(params.count, currentImageData);
            });

            const folder2 = gui.addFolder('Particle System');
            folder2.add(params, 'count', 5000, 80000, 5000).name('Density').onFinishChange(val => {
                generateParticles(val, currentImageData);
            });
            
            folder2.add(params, 'size', 10, 1000).name('Size').onChange(val => {
                if(material) material.uniforms.uSize.value = val;
            });

            folder2.add(params, 'opacity', 0.1, 1.0).name('Opacity').onChange(val => {
                if(material) material.uniforms.uOpacity.value = val;
            });

            folder2.add(params, 'bloomStrength', 0, 3).name('Glow Intensity').onChange(val => {
                if(composer.bloomPass) composer.bloomPass.strength = val;
            });
        }

        function initFileUpload() {
            const fileInput = document.getElementById('file-input');
            fileInput.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = function() {
                        processImageToParticles(img, false); // æ‰‹å‹•ä¸Šå‚³éåˆå§‹è¼‰å…¥
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
                this.value = '';
            });
        }

        function generateParticles(count, imgData = null) {
            if (particles) {
                scene.remove(particles);
                particles.geometry.dispose();
            }

            geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const sizes = [];
            const randomness = [];

            const displayWidth = 100;
            const displayHeight = 100;

            if (imgData) {
                let finalWidth, finalHeight;
                if (imgData.aspectRatio >= 1) {
                    finalWidth = displayWidth;
                    finalHeight = displayWidth / imgData.aspectRatio;
                } else {
                    finalWidth = displayHeight * imgData.aspectRatio;
                    finalHeight = displayHeight;
                }

                const data = imgData.data;
                const w = imgData.width;
                const h = imgData.height;

                for (let i = 0; i < count; i++) {
                    const px = Math.floor(Math.random() * w);
                    const py = Math.floor(Math.random() * h);
                    
                    const index = (py * w + px) * 4;
                    
                    const r = data[index] / 255;
                    const g = data[index + 1] / 255;
                    const b = data[index + 2] / 255;
                    const a = data[index + 3];

                    if (a < 20 || (r+g+b) < 0.05) {
                         colors.push(0, 0, 0); 
                    } else {
                        colors.push(r, g, b);
                    }

                    const u = (px / w) - 0.5;
                    const v = (py / h) - 0.5;

                    const x = u * finalWidth;
                    const y = -v * finalHeight; 

                    const brightness = 0.299 * r + 0.587 * g + 0.114 * b;
                    const z = brightness * params.depthStrength; 

                    positions.push(x, y, z);
                    sizes.push(Math.random() * 0.5 + 0.5); 
                    randomness.push(Math.random());
                }

            } else {
                const galaxyColor1 = new THREE.Color('#00ffff');
                const galaxyColor2 = new THREE.Color('#ff00ff');

                for (let i = 0; i < count; i++) {
                    const r = Math.random() * 50;
                    const spinAngle = r * 0.2;
                    const branchAngle = (i % 3) * ((Math.PI * 2) / 3);
                    
                    const randomX = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1) * (10 - r * 0.1);
                    const randomY = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1) * (10 - r * 0.1);
                    const randomZ = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1) * (10 - r * 0.1);

                    const x = Math.cos(spinAngle + branchAngle) * r + randomX;
                    const y = (Math.random() - 0.5) * (r * 0.2) + randomY; 
                    const z = Math.sin(spinAngle + branchAngle) * r + randomZ;

                    positions.push(x, y, z);

                    const mixedColor = galaxyColor1.clone().lerp(galaxyColor2, r / 50);
                    colors.push(mixedColor.r, mixedColor.g, mixedColor.b);

                    sizes.push(Math.random());
                    randomness.push(Math.random());
                }
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            geometry.setAttribute('randomness', new THREE.Float32BufferAttribute(randomness, 1));

            if (!material) {
                material = new THREE.ShaderMaterial({
                    uniforms: {
                        uTime: { value: 0 },
                        uPixelRatio: { value: renderer.getPixelRatio() },
                        uSize: { value: params.size },
                        uOpacity: { value: params.opacity }, 
                        uPinch: { value: 0 }
                    },
                    vertexShader: `
                        uniform float uTime;
                        uniform float uPixelRatio;
                        uniform float uSize;
                        uniform float uPinch;
                        
                        attribute float size;
                        attribute float randomness;
                        attribute vec3 color;
                        
                        varying vec3 vColor;

                        void main() {
                            vec3 pos = position;
                            
                            // ä¿æŒå‘¼å¸æ•ˆæœ
                            float wave = sin(pos.x * 0.1 + uTime) * 0.5 + cos(pos.y * 0.1 + uTime) * 0.5;
                            pos.z += wave * 0.5; 

                            vec3 dir = normalize(pos);
                            if (length(pos) < 0.1) dir = vec3(0.0, 0.0, 1.0);
                            pos += dir * uPinch * 30.0;
                            
                            // ä¿æŒéš¨æ©Ÿé–ƒçˆ
                            pos.x += sin(uTime * 5.0 + randomness * 100.0) * 0.1;
                            pos.y += cos(uTime * 5.0 + randomness * 100.0) * 0.1;

                            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                            
                            gl_PointSize = (uSize * size * (1.0 + uPinch * 1.5)) * uPixelRatio * (1.0 / -mvPosition.z);
                            gl_PointSize = min(gl_PointSize, 500.0);

                            gl_Position = projectionMatrix * mvPosition;
                            
                            vColor = color + vec3(uPinch * 0.5);
                        }
                    `,
                    fragmentShader: `
                        uniform float uOpacity; 
                        varying vec3 vColor;
                        
                        void main() {
                            vec2 xy = gl_PointCoord.xy - vec2(0.5);
                            float ll = length(xy);
                            if(ll > 0.5) discard;
                            
                            float alpha = (0.5 - ll) * 2.0;
                            alpha = pow(alpha, 2.0);

                            gl_FragColor = vec4(vColor, alpha * uOpacity);
                        }
                    `,
                    transparent: true,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending
                });
            }

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        // --- MediaPipe ---
        function initMediaPipe() {
            const videoElement = document.getElementById('video-input');
            const statusDot = document.getElementById('cam-status');
            const statusText = document.getElementById('status-text');

            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1, 
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandsResults);

            cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });

            // ä¸å†è‡ªå‹•å•Ÿå‹•ï¼Œç­‰å¾…ç”¨æˆ¶é»æ“ŠæŒ‰éˆ•
        }

        function onHandsResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handPresent = true;
                controls.autoRotate = false;

                const landmarks = results.multiHandLandmarks[0];
                
                const palmX = landmarks[9].x;
                const palmY = landmarks[9].y;
                targetRotationY = (palmX - 0.5) * 6; 
                targetRotationX = (palmY - 0.5) * 3;

                const wrist = landmarks[0];
                const middleKnuckle = landmarks[9];
                const handSize = Math.sqrt(
                    Math.pow(wrist.x - middleKnuckle.x, 2) + 
                    Math.pow(wrist.y - middleKnuckle.y, 2)
                );
                
                const minHand = 0.05; 
                const maxHand = 0.25; 
                const minZ = 50;      
                const maxZ = 300;     

                let normalizedSize = (handSize - minHand) / (maxHand - minHand);
                normalizedSize = Math.max(0, Math.min(1, normalizedSize));

                targetCameraZ = maxZ - (normalizedSize * (maxZ - minZ));

                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const distance = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) + 
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );

                const pinchThreshold = 0.12;
                if(distance < pinchThreshold) {
                    pinchStrength = Math.min(1, (pinchThreshold - distance) / pinchThreshold);
                } else {
                    pinchStrength = 0;
                }

            } else {
                handPresent = false;
                controls.autoRotate = false; 
                pinchStrength = Math.max(0, pinchStrength - 0.05);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            if(material) material.uniforms.uPixelRatio.value = renderer.getPixelRatio();
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            if (material) {
                material.uniforms.uTime.value = time;
                material.uniforms.uPinch.value += (pinchStrength - material.uniforms.uPinch.value) * 0.1;
            }

            controls.update();

            if (handPresent) {
                if(particles) {
                    particles.rotation.y += (targetRotationY - particles.rotation.y) * 0.08;
                    particles.rotation.x += (targetRotationX - particles.rotation.x) * 0.08;
                }
                // æ‰‹å‹¢æ§åˆ¶æ™‚ï¼Œæ›´æ–° targetCameraZ ä¸¦å¹³æ»‘ç§»å‹• (æ³¨æ„ï¼šé€™è£¡ä¸ç›´æ¥ä¿®æ”¹ zï¼Œè€Œæ˜¯èˆ‡ä¸‹æ–¹å…¨åŸŸ z æ›´æ–°åˆä½µ)
                // å…¶å¯¦æ‰‹å‹¢æ”¹è®Šçš„æ˜¯ targetCameraZï¼Œä¸‹æ–¹çš„å…¨åŸŸæ›´æ–°æœƒè™•ç†å®ƒ
            } else {
                // --- å¾…æ©Ÿéš¨æ©Ÿæ¼‚æµ®å‹•ç•« ---
                if(particles && params.floating) {
                    const speed = params.floatSpeed;

                    // X è»¸ï¼šè¼•å¾®ä¿¯ä»°
                    const targetX = Math.sin(time * 0.3 * speed) * 0.15;
                    particles.rotation.x += (targetX - particles.rotation.x) * 0.02;

                    // Y è»¸ï¼šå·¦å³æ“ºå‹• (é™åˆ¶åœ¨ 90 åº¦ç¯„åœå…§)
                    const maxAngle = Math.PI / 4; 
                    const rawWave = (Math.sin(time * 0.5 * speed) + Math.cos(time * 0.2 * speed));
                    const targetY = (rawWave / 2) * maxAngle;
                    
                    particles.rotation.y += (targetY - particles.rotation.y) * 0.02;
                }
            }

            // ä¿®æ”¹ï¼šå…¨åŸŸç›¸æ©Ÿ Z è»¸å¹³æ»‘ç§»å‹•
            // ç„¡è«–æœ‰ç„¡æ‰‹å‹¢ï¼Œéƒ½åŸ·è¡Œé€™è¡Œï¼Œä»¥å¯¦ç¾é–‹å ´å‹•ç•« (å¾ 5 åˆ° 150) å’Œæ‰‹å‹¢ç¸®æ”¾ (ç›®æ¨™è®Šæ›´)
            camera.position.z += (targetCameraZ - camera.position.z) * 0.04;

            composer.render();
        }
    </script>
</body>
</html>
